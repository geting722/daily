/*

最近阿彭的股票一片绿，本着大跌就是加仓信号的原则，阿彭急需一大笔资金投入股票市场。

上帝可能可怜阿彭的不切实际想法，给了他一场白日梦，即白日做梦之捡钞票游戏。

捡钞票游戏是这样的，钞票从天上往下掉，且只会掉在 [0, 10] 范围内，具体的坐标范围如下图所示。


阿彭初始站在位置5上，且每秒只能在移动不超过1米的范围内接住掉落的钞票，如果没有接住，钞票就会消失。例如，在刚开始的一秒内，阿彭 只能接到4、5、6这三个位置其中一个位置的钞票。

阿彭想要接住尽可能多的钞票（钞票面额相同），你能帮帮他吗？

Input
多组样例。每组样例输入一个 m (0 < m < 100000)，表示有 m 张钞票。

在接下来的 m 行中，每行有两个整数 a b (0 < b < 100000)，表示在第 b 秒的时候有一张钞票掉落在 a 点上。

注意，同一个点上同一秒可能掉落多张钞票。m = 0 时输入结束。

C++ 注意文件头不能使用 bits/stdc++.h，G++可以使用

java 类名 注意使用成 Main

Output
输出一个整数 x，表示阿彭 可能接住的最多的钞票数。

思路：dp[t][x]是t秒在x的位置有多少钞票，找最大值就一直往后面递推这样
状态转移方程dp[t][x]=max(dp[t-1][x-1],dp[t-1][x],dp[t-1][x+1])+a[t][x];
但是从上往下递推比较麻烦所以从下往上递推跟上次那个三角形的那个dp题一样
这样状态转移方程为int maxa=max(dp[i+1][j],dp[i+1][j+1]);
				dp[i][j]+=max(maxa,dp[i+1][j-1]);

*/
```
#include <bits/stdc++.h>
using namespace std;
const int maxn = 1e5+10;
int dp[maxn][20];
int n;
int main()
{

	while(cin>>n)
	{
		memset(dp,0,sizeof dp);
		if(n==0)
			break;
		int m=-1;
		while(n--)
		{
			int a,b;
			cin>>a>>b;
			dp[b][a+1]++;
			m=max(m,b);
		}
		for(int i=m-1; i>=0; i--)
		{
			for(int j=1; j<=11; j++)
			{
				int maxa=max(dp[i+1][j],dp[i+1][j+1]);
				dp[i][j]+=max(maxa,dp[i+1][j-1]);
			}
		}
		cout<<dp[0][6]<<endl;
	}
	return 0;
}
```
